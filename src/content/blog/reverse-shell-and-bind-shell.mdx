---
title: "Reverse Shell & Bind Shell"
description: "Reverse Shell and Bind Shell Explained (with Practical Samples)"
pubDate: "Sep 20 2025"
image: /image/blog-cover/reverse-shell-bind-shell.jpg
categories:
  - tech
tags:
  - Malware analysis
  - Reverse Shell
  - Bind Shell
---

import Collapse from "../../components/mdx/Collapse.astro";
import Diff from "../../components/mdx/Diff.astro";
import Error from "../../components/mdx/Error.astro";
import Info from "../../components/mdx/Info.astro";
import Kbd from "../../components/mdx/Kbd.astro";
import Success from "../../components/mdx/Success.astro";
import Warning from "../../components/mdx/Warning.astro";
import TimeLine from "../../components/mdx/TimeLine.astro";
import LinkCard from "../../components/mdx/LinkCard.astro";

## TL;DR 

Eyyy, welcome back, it has been a month since my last blog, right? Haha...

While playing around with Malware, I came across two samples about **Reverse Shell** and **Bind Shell**. Both are pretty interesting, and in this blog, I will share how to differentiate between the two, plus a bit of practical analysis with Malwares caught in the wild. 

Enjoy the read!

## Bind Shell

**Bind Shell** is a type of attack where the infected host **opens a listening socket**, waiting for attacker to connect. Once the attacker connects, they can gain remote access and control of the machine through that socket, often with **full command injection capability** right from their own terminal.

![bind-shell](/image/reverse-shell-bind-shell/bind-shell.png)

## Sample Analysis

The link below is a Bind Shell Sample (RAT).

<LinkCard
  title="Bind Shell Sample"
  desc="Oh, a malware hehe"
  url="https://github.com/hwangstice/malware-samples/tree/main/RAT.BindShell"
  img="/image/reverse-shell-bind-shell/use-your-head.jpg"
/>

### Static Analysis

Let's find the **SHA256** and **MD5** of this malware.

![bind-shell-sha256-md5](/image/reverse-shell-bind-shell/bind-shell-sha256-md5.png)

From **VirusTotal**, I know this sample is a type of **Trojan**.

![bind-shell-vt](/image/reverse-shell-bind-shell/bind-shell-vt.png)

Now, I check the strings using the tool named `FLOSS.exe` from **FlareVM**. This is a great tool since this prints out any arrays of characters that are greater than length 4.

![bind-shell-floss](/image/reverse-shell-bind-shell/bind-shell-floss.png)

After checking `flossout.txt` for a while, I find out these suspicious information.

```
@SSL support is not available. Cannot connect over SSL. Compile with -d:ssl to enable.
@https
@No uri scheme supplied.
InternetOpenW
InternetOpenUrlW
@wininet
@wininet
MultiByteToWideChar
@kernel32
@kernel32
MessageBoxW
@user32
@user32
@[+] what command can I run for you
@[+] online
@NO SOUP FOR YOU
@\mscordll.exe
@Nim httpclient/1.0.6
@/msdcorelib.exe
@AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
@intrt explr
@http://serv1.ec2-102-95-13-2-ubuntu.local
```

&#8594; This shows calls to APIs `InternetOpenW`, `InternetOpenUrlW`, two suspicious executables `\mscordll.exe` and `/msdcorelib.exe`, a path to **Startup** folder, and even a domain named `http://serv1.ec2-102-95-13-2-ubuntu.local`.

### Dynamic Analysis

Here is **initial detonation** when there is no **INETSIM (REMnux)**.

![bind-shell-init-det](/image/reverse-shell-bind-shell/bind-shell-init-det.png)

Let's start with **Network-based Indicator**. Here, I create **an INETSIM (REMnux)** to give the malware something to talk to, then use **Wireshark** to catches any suspicious packets.

![bind-shell-inetsim](/image/reverse-shell-bind-shell/bind-shell-inetsim.png)

Now, I am going to detonate the malware. The first thing is to **arm the binary**, then look for any **HTTP requests** from **Wireshark**.

![bind-shell-arm](/image/reverse-shell-bind-shell/bind-shell-arm.png)

![bind-shell-wireshark](/image/reverse-shell-bind-shell/bind-shell-wireshark.png)

&#8594; I can conclude that it is potentially downloading a file named `msdcorelib.exe`.

In **Host-based Indicator**, I use `procmon` with the following filters.

![bind-shell-filters](/image/reverse-shell-bind-shell/bind-shell-filters.png)

When I detonate the malware, I can see that it is creating a file named `mscordll.exe`. This file name doesn't match what I saw from **Wireshark** since it uses a common technique named **dechaning** or **decoupling** that you download a web resource and write it to disk under a seperate name. 

I also check to see if it is truly writing the file `mscordll.exe` to the disk.

![bind-shell-write-check](/image/reverse-shell-bind-shell/bind-shell-check-write.png)

&#8594; **Persistence mechanism** of this malware.

Now, what happen when a host needs to make a connection to some other hosts? The host itself needs to understand the concept of **TCP** if it is going to make a TCP connection, and there are classes of functions that the OS needs to understand to be able to perform that TCP connection.

From **host-based view**, I can pay attention to indicators like **a socket opens**, ... and these come from the host itself. But those connections cannot be caught on the wire, so I cannot see them from **Wireshark**, they happen on the host, and that's where I should look for. One of them is **openning a socket for TCP connection** from the host.

Here, I use a tool named `tcpview.exe` from **FlareVM**, and successfully catch the TCP connection!

![bind-shell-tcpview](/image/reverse-shell-bind-shell/bind-shell-tcpview.png)

&#8594; It listens to all addresses at local port `5555`.

When I connect to the socket on port `5555`, I get **Base64 Encoded data**.

![bind-shell-base64](/image/reverse-shell-bind-shell/bind-shell-base64.png)

Now, I have command injection capability.

![bind-shell-command-injection](/image/reverse-shell-bind-shell/bind-shell-command-injection.png)

I use `procmon` with the following filters to have a wider view of this command injection capability.

![bind-shell-procmon-2](/image/reverse-shell-bind-shell/bind-shell-procmon-2.png)

When I type `whoami`, it creates and runs the file named `whoami.exe` in **System32**. In the end, it sends the result via TCP socket connection.

![bind-shell-whoami-1](/image/reverse-shell-bind-shell/bind-shell-whoami-1.png)

![bind-shell-whoami-2](/image/reverse-shell-bind-shell/bind-shell-whoami-2.png)

![bind-shell-whoami-3](/image/reverse-shell-bind-shell/bind-shell-whoami-3.png)

## Reverse Shell

Similar to **Bind Shell**, **Reverse Shell** is another type of remote shell attack. However, in this case, the attacker sets up a listener. When the binary is executed, it reaches out and connects to that listener, opens a command shell, and lets the attacker input commands!

![reverse-shell](/image/reverse-shell-bind-shell/reverse-shell.png)

## Sample Analysis

The link below is a Reverse Shell Sample (RAT).

<LinkCard
  title="Reverse Shell Sample"
  desc="Hehe, another sample"
  url="https://github.com/hwangstice/malware-samples/tree/main/RAT.ReverseShell"
  img="/image/reverse-shell-bind-shell/another-sample.jpg"
/>

### Static Analysis

First of all, I find **MD5** and **SHA256** of this sample.

![reverse-shell-md5-sha256](/image/reverse-shell-bind-shell/reverse-shell-md5-sha256.png)

Have a quick look over **VirusTotal**, this sample is a **Trojan**.

![reverse-shell-vt](/image/reverse-shell-bind-shell/reverse-shell-vt.png)

Playing around with the strings via `FLOSS.exe`, these are the only useful information.

![reverse-shell-floss](/image/reverse-shell-bind-shell/reverse-shell-floss.png)

```
@cmd.exe /c 
@exit
@.local
@iterators.nim(189, 11) `len(a) == L` the length of the seq changed while iterating over it
@kadusus
```

There is not much information here, let's head to Dynamic Analysis.

### Dynamic Analysis

In initial detonation **(without INETSIM)**, nothing happens **(˘･_･˘)**.

Now, I setup the **INETSIM (REMnux)**.

![reverse-shell-inetsim](/image/reverse-shell-bind-shell/reverse-shell-inetsim.png)

When I detonate the sample again, and inspect **Wireshark**, I find a **DNS**, which is a good **Network Signature**.

![reverse-shell-wireshark](/image/reverse-shell-bind-shell/reverse-shell-wireshark.png)

If you recall, when I checked the binary's strings, I only found **kadusus** and **local**, not the full domain name. This is likely because the malware author used a trick where **the full string is built at runtime**.

So, `aaaaaaaaaaaaaaaaaaaa.kadusus.local` become a suspicious **DNS record**.

However, there is no TCP, HTTP, or any other indicators of any other network traffics in **Wireshark**. This sample only looks for the above DNS.

Here, I have a solution to inspect this further. Instead of making the sample sends connection to DNS `aaaaaaaaaaaaaaaaaaaa.kadusus.local` via **INETSIM (REMnux)**, I make it establish connection to my host via **host files** (`cmder` needs to be opened with **administator**).

![reverse-shell-edit-host](/image/reverse-shell-bind-shell/reverse-shell-edit-host.png)

![reverse-shell-edit](/image/reverse-shell-bind-shell/reverse-shell-edit.png)

Now, the sample is talking to my host whenever it tries to reach the domain I saw earlier.

However, there is a question of how this sample connect to that DNS record? How can I find out? 

So... why not `procmon`!? This is my filters.

![reverse-shell-filters](/image/reverse-shell-bind-shell/reverse-shell-filter.png)

When I detonate the malware, there are **Potential Calls** out to specified **DNS Record** on **HTTPS port** (`443`).

![reverse-shell-dns-call-out](/image/reverse-shell-bind-shell/reverse-shell-dns-call-out.png)

At this point, the sample thinks its home server is my host, I can use `ncat` listenning to port `443` and see what happens. And I have a successful connection!

![reverse-shell-find-tcp](/image/reverse-shell-bind-shell/reverse-shell-find-tcp.png)

When I throw the command `whoami`, I get **TCP Receive** and **TCP Connect**, also the output from the terminal.

![reverse-shell-whoami](/image/reverse-shell-bind-shell/reverse-shell-whoami.png)

## Final Words 

After a long journey, I finally get here. It's fascinating to see these techniques in malware.

Although the samples are quite naive and not very sophisticated, I have learned a lot. And I truly believe that with a strong foundation, I can go even further ❤️.